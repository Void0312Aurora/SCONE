# SCONE：结构化可学习“物理引擎 Step”规范（Draft v0.2）

> 目标：把 `docs/temp-01.md` 里的“愿景/论述”落到可实现、可验收、可迭代的工程与研究规范。

## 1. 背景与问题定义

我们希望把“仿真引擎”抽象成一个 **可组合的 step 生成器**：给定状态、几何与输入，输出下一步状态，并产出可核算的诊断（能量/功率账本、约束误差、接触信息等）。与仅拟合连续 ODE 的方法相比，本项目关注的是**引擎级 step 语义**：确定性、可回退、可 debug、长时稳定。

## 2. 范围（Scope）

### 2.1 目标（Goals）

1. **模块化 step**：将一步仿真拆为“保守 / 耗散-驱动 / 非光滑事件”三类语义模块，并把约束语义显式抽出为可插拔层（可与保守核合并实现）：
   - (A) `SymplecticCore`：保守（或近保守）连续演化的结构保持推进；
   - (B) `DissipationInputLayer`：耗散/驱动（开系统端口）处理；
   - (C) `ConstraintLayer`：约束满足与反力/乘子诊断（理想情况下功率≈0；数值偏差作为误差指标）；
   - (D) `EventLayer`：非光滑接触/摩擦/冲量等事件求解。
2. **统一能量/功率账本（Energy–Power Ledger）**：每层都能输出可核算的能量变化、输入功率、耗散、冲量做功等指标。
3. **确定性与 fail-safe**：同一输入应可复现；当学习模块产生不稳定/不合法结果时，可回退到基线求解策略（或限幅）以保持仿真继续运行。
4. **可训练**：支持监督/弱监督/自监督训练；训练目标包含状态误差与结构一致性指标（辛性、耗散不等式、互补条件等）。

### 2.2 非目标（Non-goals，当前不做）

- 渲染、资产管线、编辑器、网络同步等“游戏引擎”层功能。
- 大规模通用碰撞库（先以少量刚体形状/解析接触为主，逐步扩展）。
- 复杂可变拓扑（断裂/粘连）与流体（除非后续明确选题）。

## 3. 术语与数据结构（Terminology & Data）

### 3.1 状态与输入

- **构形流形**：记系统构形空间为流形 `Q`（刚体系统常见为若干 `SE(3)`/关节流形的乘积）。
- **状态流形（推荐表述）**：
  - 理论与“辛结构”叙事：以相空间 `T*Q` 为主，状态写作 `x = (q, p)`，并使用其典范辛形式/辛 2-形式。
  - 工程与接触求解器：允许用切丛 `TQ` 上的表示 `x = (q, v)`（多数物理引擎天然存 `q,v`）。
- **一致性要求**：若实现采用 `(q, v)`，则需显式提供与 `(q, p)` 的互相转换（正则拉格朗日情形下由 Legendre 变换给出，常见简化为 `p = M(q) v`、`v = M(q)^{-1} p`），并确保能量/功率账本在两种表示下可核算一致。
- 时间步长 `dt`：固定或离散集合（用于训练与评测的可控性）。
- 外部输入 `u`：控制/驱动力（可选）。

### 3.2 约束与接触

- **几何化约束表述（推荐）**：
  - **Holonomic**：约束定义构形子流形 `C = { q ∈ Q | g(q)=0 } ⊂ Q`；速度约束为 `v ∈ T_q C`，其坐标表达为 `Dg(q) v = 0`。
  - **Non-holonomic**：约束定义在切空间上的分布 `D(q) ⊂ T_q Q`（不一定可积），常用坐标表达为 `A(q) v = 0`；其余切空间约束可用余切空间的消子/annihilator `D(q)° ⊂ T_q*Q` 来表达。
- **相空间上的约束（按需）**：holonomic 情形可视为 `T*C ⊂ T*Q`；若需要在事件层/冲量层直接约束动量，可将约束写为 `p ∈ T_q*C` 或用乘子/投影实现。
- 接触几何：对每个潜在接触对定义符号距离 `phi(q)`、法向 `n(q)`、切向基 `t_i(q)`。

### 3.3 诊断（Diagnostics）

统一输出结构（字段可随实现扩展）。建议采用 RFC 风格的最小契约：

**MUST**
- `energy.E_total`（或 `H`）、分层能量变化 `energy.dE_A/dE_B/dE_C/dE_D`
- `contacts.penetration_max`（无接触时为 0）
- `constraints.residual_pos/residual_vel`、`constraints.power_error`（无约束时为 0）
- `failsafe.triggered`、`failsafe.reason`

**SHOULD**
- `power.P_in`、`power.P_diss`（B 层账本）
- `event.W_impulse`、`event.dE_event`（D 层离散账本；见下）
- `contacts.lambda_n/lambda_t`、`contacts.complementarity_residual`
- `solver.iters`、`solver.status`
- `failsafe.alpha_blend`（若使用混合/插值回退）

- `energy`: `E_kin`, `E_pot`, `E_total`（或 `H`），以及分层能量变化 `dE_A/dE_B/dE_C/dE_D`。
- `power`: `P_in`（输入功率）、`P_diss`（耗散功率，期望 `>=0`）。
- `event`: 事件层离散账本（推荐 `W_impulse`, `dE_event`；见 5.4）。
- `constraints`: 位置/速度约束残差与投影/乘子信息（若启用）。
- `contacts`: 接触点、穿透深度、冲量、摩擦模式、互补残差（若启用）。
- `failsafe`: 是否触发回退、回退原因码、回退前后误差对比（关键用于工程可控与论文实验）。

## 4. 核心接口（Engine-level API）

> 本节是“标准化”的核心：先把接口定死，再谈模型与实现细节。

### 4.1 顶层引擎接口

```text
Engine.step(x_t, dt, context) -> (x_{t+dt}, diagnostics)
```

其中 `context` 至少包含：
- 几何/拓扑（刚体形状、关节、接触对候选）
- 物理参数（质量、惯量、重力等）
- 输入 `u_t`（可选）

### 4.2 三层模块接口

```text
SymplecticCore.step(x, dt, context) -> (x*, diag_A)
DissipationInputLayer.step(x*, dt, context) -> (x**, diag_B)
ConstraintLayer.project(x**, dt, context) -> (x***, diag_C)
EventLayer.resolve(x***, dt, context) -> (x_next, diag_D)
```

组合语义（默认 Lie–Trotter splitting）：
`x_next = D(C(B(A(x))))`。

可选：支持 Strang splitting（提高精度）：
`x_next = A(dt/2) -> B(dt) -> A(dt/2) -> C(dt) -> D(dt)`（事件层通常放末端；若要中插需额外定义一致性规则）。

> 接触/约束强耦合场景下，单次 splitting 可能导致“先推进再强行纠正”的病态行为（穿透过大、冲量异常）。实现上可采用：更小 `dt`、预测-校正（position correction）、或在 `C/D` 之间做有限次局部迭代，并将其作为可控的工程参数暴露到配置中。

## 5. 分层语义约束（Layer Semantics）

### 5.1 (A) SymplecticCore：保守核

**最低要求**
- 在无耗散/无事件场景下，长时间 rollout 的数值稳定性明显优于黑箱模型。

**可选约束（建议纳入训练/评测）**
- 辛性约束：离散映射近似满足 `J`-辛结构（在 `T*Q` 上定义；若内部采用 `(q,v)∈TQ`，应通过离散变分/Legendre 映射解释并检验同等辛性）。
- 能量漂移可控：`|E(t) - E(0)|` 随时间增长缓慢或有界（取决于系统与积分器阶）。

### 5.2 (B) DissipationInputLayer：耗散/驱动（开系统）

该层负责“不可逆”与“开系统”效应，并输出可核算账本：

- 输入功率 `P_in`（来自 `u` 或环境驱动）
- 耗散功率 `P_diss >= 0`（例如 Rayleigh dissipation、接触粘性、阻尼等）
- 账本一致性（期望在统计意义上成立）：
  `dE_B/dt ≈ P_in - P_diss`。

> 该层不直接负责“理想约束”的满足；约束由 (C) 层单独处理，以避免账本语义混淆。

### 5.3 (C) ConstraintLayer：约束满足与反力诊断

约束在几何上定义为子流形/分布（见 3.2），实现上建议提供两种风格（可配置切换）：

1. **投影/乘子层（工程友好）**：在 `q`/`v` 上投影回约束流形/分布，或求解拉格朗日乘子/约束冲量。
2. **结构保持（理论更干净）**：将约束内生于 (A) 的离散变分/约束辛积分器中（此时 (C) 可退化为诊断层）。

账本语义：
- 理想约束反力**不做功**，期望其约束功率/功 `≈ 0`；数值偏差应被记录为 `constraints.power_error`（或等价字段），用于评测与 fail-safe 判据。

### 5.4 (D) EventLayer：非光滑事件（互补/冲量）

该层处理速度跃迁与接触模式切换，典型包括：
- 碰撞（恢复系数/塑性）
- 多点堆叠接触
- 库仑摩擦（粘/滑）

**MVP 默认数值方案（建议在 M1 固定下来，避免实现分叉）**
- **优先基线（最简、可控、可复现）**：解析冲量/速度级 time-stepping（单点或少量接触），支持恢复系数 `e` 与库仑摩擦（切向冲量投影到摩擦锥/圆）。
- **扩展基线（更“引擎味”）**：time-stepping + Projected Gauss–Seidel（PGS）/NCP 求解，面向多点堆叠；要求固定接触排序与迭代上限以满足确定性契约。

**规范要求**
- 输出冲量 `lambda_n, lambda_t`（或等价量）与互补残差指标。
- 冲量更新的默认语义在动量上最自然：`p+ = p- + J(q)^T λ`；若状态存为速度，则应等价实现 `v+ = v- + M(q)^{-1} J(q)^T λ` 并保持账本可核算一致。
- **离散账本（推荐字段）**：事件层是冲量/模式切换，语义上更自然用离散功/能量跳变量而非功率：
  - `event.W_impulse`：冲量做功（或其可核算等价量）
  - `event.W_position_correction`（可选）：若事件层包含位置夹紧/投影等数值校正，建议将其“等效做功/能量改动”单独记录，避免与冲量账本混淆
  - `event.dE_event`：事件导致的总能量变化（含恢复系数/塑性/摩擦等模型项）
  - 若需要与 B 层统一到“功率”，应明确采用 `event.W_impulse / dt` 的约定并标注为派生量。
- 提供 fail-safe：当求解失败/违反基本不等式（例如产生能量爆炸或严重穿透）时回退到基线策略。

## 6. Fail-safe 与确定性（Determinism）

### 6.1 Fail-safe 触发条件（建议最小集）

为避免“动不动全回退”，建议将触发条件分级（阈值均应写入配置并记录在日志中）：

- **Hard fail（必须回退）**
  - 数值非法：`NaN/Inf`、求解器崩溃/不返回
  - 穿透/约束严重失稳：`contacts.penetration_max` 或 `constraints.residual_*` 超过硬阈值
- **Soft fail（优先降级/混合）**
  - 互补/摩擦残差偏大、迭代不充分但仍可运行
  - 账本轻中度异常：在“应耗散”的设置下出现非物理能量增长（需结合容差与已知输入功率判断）

### 6.2 回退策略（从轻到重）

1. **参数限幅/投影**（Soft fail 首选）：把学习到的 `mu/e/k/d` 等投影到物理可行域。
2. **混合/插值**（Soft fail 次选）：`output = α * learned + (1-α) * baseline`，并记录 `α`。
3. **完全回退**（Hard fail 必选）：使用传统求解器/规则（解析冲量、LCP/NCP、惩罚法等）。

### 6.3 确定性要求

确定性建议分两档（默认以工程可用为先）：

- **Tolerance deterministic（默认）**：同一 `(x_t, dt, context)` 在同一硬件/软件配置下输出在容差内一致；容差应分别对状态、能量与事件模式定义（并写入配置）。
- **Bitwise deterministic（可选）**：要求逐 bit 一致；通常需要限制并行归约、固定接触排序、固定求解迭代路径，并可能需要禁用部分 GPU 非确定算子。

实现约束：
- 事件/约束求解器需固定迭代上限、容差与排序规则；避免不稳定的随机分支。
- 若启用 GPU/并行求解，需认识到浮点非结合性会带来微小差异；此时至少应保证 tolerance deterministic，并在日志中记录运行环境（设备、精度、库版本）。

## 7. 训练与数据（Training Spec）

### 7.1 数据形态

最低可用数据：
- 轨迹：`{x_t}`（可多步），以及可选输入 `{u_t}`。
- 环境/几何参数：质量、惯量、几何尺度、摩擦/恢复系数（可选标签）。

可选增强（若可获得，能显著提升事件层可学性）：
- 接触点/法向/冲量标签（来自高精度仿真或传感估计）。
- 约束反力/关节力矩标签。

### 7.2 目标函数（建议拆分与可消融）

1. **状态拟合**：一步或多步 rollout 误差（位置/速度/角速度）。
2. **结构一致性**：
   - 辛性误差（A 层）
   - 账本一致性误差（B/D 层；C 层约束功率偏差单列）
   - 约束残差与约束功率偏差（若启用）
3. **事件一致性**：
   - 互补残差（非穿透 + 法向冲量互补）
   - 摩擦锥约束与粘滑切换一致性

### 7.3 训练流程（推荐 curriculum）

1. 无接触数据上训练 (A)+(B) 的稳定 rollout（先稳住长时）。
2. 引入接触数据，冻结 (A)(B)，只训练 (D) 的“闭合项”（例如 `mu/e` 场或软接触参数）。
3. 端到端微调（可选）：**默认不要求事件层/回退逻辑端到端可微**，以保证引擎基线的可控与可复现；如需研究可微训练，可提供可微近似/软回退，并在训练期先采用“只记录不回退”的策略以避免梯度被硬截断。

## 8. 评测协议（Evaluation）

最小必做指标（每个指标都应能从 Diagnostics 直接读出）：

- **长时稳定性**：多步 rollout 误差随时间增长曲线、能量漂移曲线。
- **耗散正确性**：在应耗散系统中 `E_total` 单调性/统计一致性，`P_diss >= 0` 违反率。
- **约束保持**：`||g(q)||`、`||A(q)v||` 随时间曲线（若启用）。
- **接触质量**：最大穿透深度、互补残差、堆叠稳定性、摩擦模式一致性。
- **事件/模式一致性（可选但强烈建议）**：分离/粘着/滑动/碰撞等模式的准确率/F1 或混淆矩阵（若可从高精度仿真生成伪标签）。
- **工程指标**：确定性测试（重复运行差异）、fail-safe 触发率与触发后误差。

对比基线建议（按选题裁剪）：
- 黑箱序列模型
- HNN/PHNN 类（若实现成本可控）
- 传统物理引擎/求解器（作为“工程基线”）

## 9. 最小可行 Demo（MVP Benchmarks）

> 用最少的 demo 覆盖三层语义，并能快速做 ablation。

建议从 3 个 demo 起步：

1. **无接触保守系统**：双摆/弹簧（验证 A 层辛性与长时稳定）。
2. **光滑耗散系统**：阻尼摆/阻尼弹簧（验证 B 层账本：输入功率与耗散）。
3. **非光滑接触**：弹跳球 + 恢复系数 / 方块滑动 + 库仑摩擦（验证 D 层互补与事件账本）。

扩展 demo（后续按选题选做）：
- 盒子堆叠（多点接触）
- 关节链 + 接触（约束与事件耦合）

## 10. 下一步行动计划（Roadmap）

> 下面的里程碑按“能尽快闭环验证”排序；每一步都应能产出可跑的脚本与可复现的指标图。

### 10.1 决策点（需要尽快拍板）

1. **优先选题方向（单选）**
   - (1) 耗散 + 长时稳定（更像方法论文）
   - (2) 接触堆叠 + 摩擦（更像引擎/图形）
   - (3) 关节约束 + 接触（更像机器人）
2. **技术栈（建议二选一）**
   - Python + JAX（偏可微与研究迭代）
   - Python + PyTorch（偏生态与工程普适）

### 10.2 里程碑（建议 4 周闭环）

每个里程碑建议固定产出物格式（便于复现与写作复用）：
- `configs/*.yaml`：固定种子、dt、场景参数、求解器/回退配置
- `logs/*.jsonl`：逐步 diagnostics 序列（单步一行）
- `plots/*.png`：能量/穿透/约束/误差等曲线

- **M1：基线 step + Diagnostics**
  - 交付：实现 A/B/C/D 的“传统版本”（不学习），并完整产出账本与接触/约束指标。
  - 验收：3 个 MVP demo 都能跑；能量/穿透/约束曲线合理；确定性测试通过。

- **M2：引入可学习闭合项（最小学习切片）**
  - 交付：只在一个层引入学习（推荐先从 D 层的 `e` 或 `mu` 开始），其余保持基线。
  - 验收：在分布内/轻度分布外上优于纯基线；fail-safe 触发率可控。

- **M3：结构一致性约束与消融**
  - 交付：加入辛性/账本/互补等约束项；做 ablation（去掉约束、去掉 fail-safe、去掉分层等）。
  - 验收：指标提升能解释；能回答“不是 HNN/PHNN 重命名”的关键对比轴。

- **M4：论文级实验与写作素材**
  - 交付：统一脚本产出所有曲线/表格；整理贡献点与失败案例。
  - 验收：可复现（固定随机种子、配置文件、日志）；能导出图表用于写作。

## 11. 开放问题（Open Questions，随实现收敛）

- 约束的实现路径：作为独立 (C) `ConstraintLayer`（投影/乘子），还是内生于 (A)（离散变分/约束辛积分）并让 (C) 退化为诊断层？
- 事件层可微性需求：训练是否需要端到端对冲量求导，还是只做弱监督/离线拟合？
- 账本的严格性：按“期望一致”还是“逐步严格不等式”来约束（取决于噪声与观测）？
