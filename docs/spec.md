# SCONE：结构化可学习“物理引擎 Step”规范（Draft v0.1）

> 目标：把 `docs/temp-01.md` 里的“愿景/论述”落到可实现、可验收、可迭代的工程与研究规范。

## 1. 背景与问题定义

我们希望把“仿真引擎”抽象成一个 **可组合的 step 生成器**：给定状态、几何与输入，输出下一步状态，并产出可核算的诊断（能量/功率账本、约束误差、接触信息等）。与仅拟合连续 ODE 的方法相比，本项目关注的是**引擎级 step 语义**：确定性、可回退、可 debug、长时稳定。

## 2. 范围（Scope）

### 2.1 目标（Goals）

1. **模块化 step**：将一步仿真拆为三层可插拔模块：
   - (A) `SymplecticCore`：保守（或近保守）连续演化的结构保持推进；
   - (B) `ContactLayer`：耗散/驱动/（可选）约束处理；
   - (C) `EventLayer`：非光滑接触/摩擦/冲量等事件求解。
2. **统一能量/功率账本（Energy–Power Ledger）**：每层都能输出可核算的能量变化、输入功率、耗散、冲量做功等指标。
3. **确定性与 fail-safe**：同一输入应可复现；当学习模块产生不稳定/不合法结果时，可回退到基线求解策略（或限幅）以保持仿真继续运行。
4. **可训练**：支持监督/弱监督/自监督训练；训练目标包含状态误差与结构一致性指标（辛性、耗散不等式、互补条件等）。

### 2.2 非目标（Non-goals，当前不做）

- 渲染、资产管线、编辑器、网络同步等“游戏引擎”层功能。
- 大规模通用碰撞库（先以少量刚体形状/解析接触为主，逐步扩展）。
- 复杂可变拓扑（断裂/粘连）与流体（除非后续明确选题）。

## 3. 术语与数据结构（Terminology & Data）

### 3.1 状态与输入

- **构形流形**：记系统构形空间为流形 `Q`（刚体系统常见为若干 `SE(3)`/关节流形的乘积）。
- **状态流形（推荐表述）**：
  - 理论与“辛结构”叙事：以相空间 `T*Q` 为主，状态写作 `x = (q, p)`，并使用其典范辛形式/辛 2-形式。
  - 工程与接触求解器：允许用切丛 `TQ` 上的表示 `x = (q, v)`（多数物理引擎天然存 `q,v`）。
- **一致性要求**：若实现采用 `(q, v)`，则需显式提供与 `(q, p)` 的互相转换（正则拉格朗日情形下由 Legendre 变换给出，常见简化为 `p = M(q) v`、`v = M(q)^{-1} p`），并确保能量/功率账本在两种表示下可核算一致。
- 时间步长 `dt`：固定或离散集合（用于训练与评测的可控性）。
- 外部输入 `u`：控制/驱动力（可选）。

### 3.2 约束与接触

- **几何化约束表述（推荐）**：
  - **Holonomic**：约束定义构形子流形 `C = { q ∈ Q | g(q)=0 } ⊂ Q`；速度约束为 `v ∈ T_q C`，其坐标表达为 `Dg(q) v = 0`。
  - **Non-holonomic**：约束定义在切空间上的分布 `D(q) ⊂ T_q Q`（不一定可积），常用坐标表达为 `A(q) v = 0`；其余切空间约束可用余切空间的消子/annihilator `D(q)° ⊂ T_q*Q` 来表达。
- **相空间上的约束（按需）**：holonomic 情形可视为 `T*C ⊂ T*Q`；若需要在事件层/冲量层直接约束动量，可将约束写为 `p ∈ T_q*C` 或用乘子/投影实现。
- 接触几何：对每个潜在接触对定义符号距离 `phi(q)`、法向 `n(q)`、切向基 `t_i(q)`。

### 3.3 诊断（Diagnostics）

统一输出结构（字段可随实现扩展）：

- `energy`: `E_kin`, `E_pot`, `E_total`（或 `H`），以及分层能量变化 `dE_A/dE_B/dE_C`。
- `power`: `P_in`（输入功率）、`P_diss`（耗散功率，期望 `>=0`）。
- `constraints`: 位置/速度约束残差与投影/乘子信息（若启用）。
- `contacts`: 接触点、穿透深度、冲量、摩擦模式、互补残差（若启用）。
- `failsafe`: 是否触发回退、回退原因码、回退前后误差对比（关键用于工程可控与论文实验）。

## 4. 核心接口（Engine-level API）

> 本节是“标准化”的核心：先把接口定死，再谈模型与实现细节。

### 4.1 顶层引擎接口

```text
Engine.step(x_t, dt, context) -> (x_{t+dt}, diagnostics)
```

其中 `context` 至少包含：
- 几何/拓扑（刚体形状、关节、接触对候选）
- 物理参数（质量、惯量、重力等）
- 输入 `u_t`（可选）

### 4.2 三层模块接口

```text
SymplecticCore.step(x, dt, context) -> (x*, diag_A)
ContactLayer.step(x*, dt, context) -> (x**, diag_B)
EventLayer.resolve(x**, dt, context) -> (x_next, diag_C)
```

组合语义（默认 Lie–Trotter splitting）：
`x_next = C(B(A(x)))`。

可选：支持 Strang splitting（提高精度）：
`x_next = A(dt/2) -> B(dt) -> A(dt/2) -> C(dt)`（事件层通常放末端；若要中插需额外定义一致性规则）。

## 5. 分层语义约束（Layer Semantics）

### 5.1 (A) SymplecticCore：保守核

**最低要求**
- 在无耗散/无事件场景下，长时间 rollout 的数值稳定性明显优于黑箱模型。

**可选约束（建议纳入训练/评测）**
- 辛性约束：离散映射近似满足 `J`-辛结构（在 `T*Q` 上定义；若内部采用 `(q,v)∈TQ`，应通过离散变分/Legendre 映射解释并检验同等辛性）。
- 能量漂移可控：`|E(t) - E(0)|` 随时间增长缓慢或有界（取决于系统与积分器阶）。

### 5.2 (B) ContactLayer：耗散/驱动/约束

该层负责“不可逆”与“开系统”效应，并输出可核算账本：

- 输入功率 `P_in`（来自 `u` 或环境驱动）
- 耗散功率 `P_diss >= 0`（例如 Rayleigh dissipation、接触粘性、阻尼等）
- 账本一致性（期望在统计意义上成立）：
  `dE_B/dt ≈ P_in - P_diss`。

约束（可选）有两种实现风格（需在实现时二选一或提供开关）：
1. **投影/乘子层**：对 `g(q)=0` 进行投影或求解乘子（工程友好）。
2. **约束坐标化**：在约束坐标上推进（理论更干净，但工程复杂）。

> 注意：约束不必等同“耗散”；若约束需要保持保守结构，建议以“约束辛积分/离散变分”路线实现，避免把它混进纯耗散项而导致不必要的结构破坏。

### 5.3 (C) EventLayer：非光滑事件（互补/冲量）

该层处理速度跃迁与接触模式切换，典型包括：
- 碰撞（恢复系数/塑性）
- 多点堆叠接触
- 库仑摩擦（粘/滑）

**规范要求**
- 输出冲量 `lambda_n, lambda_t`（或等价量）与互补残差指标。
- 冲量更新的默认语义在动量上最自然：`p+ = p- + J(q)^T λ`；若状态存为速度，则应等价实现 `v+ = v- + M(q)^{-1} J(q)^T λ` 并保持账本可核算一致。
- 能量/功率账本可核算：冲量做功、摩擦耗散、恢复系数造成的能量损失/注入（按模型定义）。
- 提供 fail-safe：当求解失败/违反基本不等式（例如产生能量爆炸或严重穿透）时回退到基线策略。

## 6. Fail-safe 与确定性（Determinism）

### 6.1 Fail-safe 触发条件（建议最小集）

- 数值非法：`NaN/Inf`、超出物理合理范围（速度/角速度上限等）。
- 约束/接触异常：约束残差或穿透深度超过阈值；互补残差过大且不收敛。
- 账本异常：在“应耗散”的设置下出现显著能量非物理增长（需结合容差与已知输入功率判断）。

### 6.2 回退策略（从轻到重）

1. **参数限幅/投影**：把学习到的 `mu/e/k/d` 等投影到物理可行域。
2. **混合/插值**：`output = α * learned + (1-α) * baseline`，并记录 `α`。
3. **完全回退**：使用传统求解器/规则（解析解、LCP/NCP、惩罚法等）。

### 6.3 确定性要求

- 同一 `(x_t, dt, context)` 在同一硬件/软件配置下输出应一致（或在容差内一致）。
- 事件求解器需固定迭代上限、容差与排序规则；避免不稳定的随机分支。

## 7. 训练与数据（Training Spec）

### 7.1 数据形态

最低可用数据：
- 轨迹：`{x_t}`（可多步），以及可选输入 `{u_t}`。
- 环境/几何参数：质量、惯量、几何尺度、摩擦/恢复系数（可选标签）。

可选增强（若可获得，能显著提升事件层可学性）：
- 接触点/法向/冲量标签（来自高精度仿真或传感估计）。
- 约束反力/关节力矩标签。

### 7.2 目标函数（建议拆分与可消融）

1. **状态拟合**：一步或多步 rollout 误差（位置/速度/角速度）。
2. **结构一致性**：
   - 辛性误差（A 层）
   - 账本一致性误差（B/C 层）
   - 约束残差（若启用）
3. **事件一致性**：
   - 互补残差（非穿透 + 法向冲量互补）
   - 摩擦锥约束与粘滑切换一致性

### 7.3 训练流程（推荐 curriculum）

1. 无接触数据上训练 (A)+(B) 的稳定 rollout（先稳住长时）。
2. 引入接触数据，冻结 (A)(B)，只训练 (C) 的“闭合项”（例如 `mu/e` 场或软接触参数）。
3. 端到端微调；fail-safe 在训练期可先“只记录不回退”或用可微近似以避免梯度被截断。

## 8. 评测协议（Evaluation）

最小必做指标（每个指标都应能从 Diagnostics 直接读出）：

- **长时稳定性**：多步 rollout 误差随时间增长曲线、能量漂移曲线。
- **耗散正确性**：在应耗散系统中 `E_total` 单调性/统计一致性，`P_diss >= 0` 违反率。
- **约束保持**：`||g(q)||`、`||A(q)v||` 随时间曲线（若启用）。
- **接触质量**：最大穿透深度、互补残差、堆叠稳定性、摩擦模式一致性。
- **工程指标**：确定性测试（重复运行差异）、fail-safe 触发率与触发后误差。

对比基线建议（按选题裁剪）：
- 黑箱序列模型
- HNN/PHNN 类（若实现成本可控）
- 传统物理引擎/求解器（作为“工程基线”）

## 9. 最小可行 Demo（MVP Benchmarks）

> 用最少的 demo 覆盖三层语义，并能快速做 ablation。

建议从 3 个 demo 起步：

1. **无接触保守系统**：双摆/弹簧（验证 A 层辛性与长时稳定）。
2. **光滑耗散系统**：阻尼摆/阻尼弹簧（验证 B 层账本：输入功率与耗散）。
3. **非光滑接触**：弹跳球 + 恢复系数 / 方块滑动 + 库仑摩擦（验证 C 层互补与事件账本）。

扩展 demo（后续按选题选做）：
- 盒子堆叠（多点接触）
- 关节链 + 接触（约束与事件耦合）

## 10. 下一步行动计划（Roadmap）

> 下面的里程碑按“能尽快闭环验证”排序；每一步都应能产出可跑的脚本与可复现的指标图。

### 10.1 决策点（需要尽快拍板）

1. **优先选题方向（单选）**
   - (1) 耗散 + 长时稳定（更像方法论文）
   - (2) 接触堆叠 + 摩擦（更像引擎/图形）
   - (3) 关节约束 + 接触（更像机器人）
2. **技术栈（建议二选一）**
   - Python + JAX（偏可微与研究迭代）
   - Python + PyTorch（偏生态与工程普适）

### 10.2 里程碑（建议 4 周闭环）

- **M1：基线 step + Diagnostics**
  - 交付：实现 A/B/C 的“传统版本”（不学习），并完整产出账本与接触/约束指标。
  - 验收：3 个 MVP demo 都能跑；能量/穿透/约束曲线合理；确定性测试通过。

- **M2：引入可学习闭合项（最小学习切片）**
  - 交付：只在一个层引入学习（推荐先从 C 层的 `e` 或 `mu` 开始），其余保持基线。
  - 验收：在分布内/轻度分布外上优于纯基线；fail-safe 触发率可控。

- **M3：结构一致性约束与消融**
  - 交付：加入辛性/账本/互补等约束项；做 ablation（去掉约束、去掉 fail-safe、去掉分层等）。
  - 验收：指标提升能解释；能回答“不是 HNN/PHNN 重命名”的关键对比轴。

- **M4：论文级实验与写作素材**
  - 交付：统一脚本产出所有曲线/表格；整理贡献点与失败案例。
  - 验收：可复现（固定随机种子、配置文件、日志）；能导出图表用于写作。

## 11. 开放问题（Open Questions，随实现收敛）

- 约束层是否与 B 层合并，还是单独作为 `ConstraintLayer`（避免语义混淆）？
- 事件层可微性需求：训练是否需要端到端对冲量求导，还是只做弱监督/离线拟合？
- 账本的严格性：按“期望一致”还是“逐步严格不等式”来约束（取决于噪声与观测）？
