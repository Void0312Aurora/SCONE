我看完这份《SCONE：结构化可学习“物理引擎 Step”规范（Draft v0.1）》了，整体结构很清晰：目标→范围→数据结构→API→语义约束→fail-safe→训练→评测→MVP→路线图，工程/论文双用途也兼顾得不错。下面我按“可能的逻辑问题/歧义”与“可进一步增强的点”两部分给你系统性反馈（都会引用原文位置）。 

---

## 可能的逻辑问题与歧义

### 1) B 层把“耗散/驱动/约束”放一起，语义上容易打架

你在 (B) 里把耗散、驱动、约束都归为 `ContactLayer`，同时又提醒“约束不必等同耗散”。 
问题在于：**约束（理想 holonomic、理想关节）本质上不做功/不耗散**，而你又要做“账本一致性 `dE_B/dt ≈ P_in - P_diss`”。这会让审稿人/工程读者疑惑：

* 约束反力/乘子项的功率在账本里算到哪里？（它理论上应为 0，但数值上可能不为 0）
* 如果约束层用投影，会引入数值耗散或能量注入，这算 B 层耗散还是误差？

**建议**：把约束从 B 层概念上拆成独立层 `ConstraintLayer`（哪怕实现上仍可选合并），让账本语义更干净：

* `SymplecticCore`：保守推进（可含理想约束的变分积分版本）
* `Dissipation/Input Layer`：只管输入功率与耗散
* `ConstraintLayer`：只管约束满足与反力诊断（账本里期望其功率≈0，偏差当作数值误差指标）

你自己也在开放问题里提出要不要拆层，这里我会把它升级为“规范层面的强建议”。 

---

### 2) A/B/C 的 splitting 顺序在接触/约束耦合场景下可能不自洽

你默认 `x_next = C(B(A(x)))`（Lie–Trotter），并提 Strang splitting。 
对“引擎级接触”来说，一个常见坑是：

* A/B 推进后状态已经“穿透很多”，C 再去解互补会变得病态（或者靠很强的修正冲量把系统拉回来，导致账本/稳定性难解释）。
  这不是说你不对，而是**需要在规范里明确**：
* 接触约束是“速度级”（time-stepping）还是“位置级”（position correction）？
* 允许多大穿透再交给 EventLayer？穿透是否要在 B 层做“预测-校正”？
* Strang 里事件层能不能中插？你说“通常放末端”，但最好给出硬规则，否则实现团队容易各做各的。

---

### 3) “确定性”目标与“GPU/并行求解器”现实存在张力

你写了确定性要求：“同一输入在同一硬件/软件配置下输出应一致”，并要求事件求解器固定排序与迭代上限。 
这很好，但规范里最好补一句边界：

* **浮点非结合性**会导致并行归约/接触排序不同而产生微差；
* 若目标是“引擎可复现”，需要定义“bitwise deterministic”还是“tolerance deterministic”。
  目前文本里是“或在容差内一致”，但容差的层级（状态、能量、接触模式）没定义。 

---

### 4) 账本（Ledger）在 C 层用“功率”表述有点不精确

你在 B 层用 `P_in/P_diss`（功率）很自然；但 C 层是冲量事件，严格说是**能量跃迁/功的离散量**，写功率会让人问“除以 dt 还是事件时长？” 
建议在规范里把 C 层 ledger 明确成**“离散功/能量跳变量”**（例如 `W_impulse`, `ΔE_event`），B 层才是功率连续积分。

---

### 5) “可训练”部分对“可微性”立场略摇摆

你在训练章节提到“端到端微调；fail-safe 训练期可先只记录不回退或用可微近似”。 
这很务实，但规范层面可以更明确一点：

* 你到底把 SCONE 定位为 “必须端到端可微” 还是 “模块可替换、训练可离线”？
  现在读起来两者都想要，容易让路线分叉。建议把它写成：
* **默认：不要求事件层端到端可微**（先做可控/可复现/可 debug）；
* **可选：提供可微近似用于研究**（但不影响引擎基线）。

---

## 可以进一步增强的地方（让它更“工程可验收 + 论文可防守”）

### A) 把“状态表示 (q,v) vs (q,p)”从“转换”提升为“契约”

你写了要提供互相转换并确保账本一致。 
建议补充一条“接口契约”：

* **内部主状态**到底是哪个？（建议统一为 `(q,v)` 方便事件层与工程；但 A 层可内部临时用 `(q,p)`）
* Diagnostics 里统一输出哪个？（例如都输出 `q,v` + `E_total`）
* 转换失败/非正则（例如质量矩阵奇异、约束导致不可逆 Legendre）的处理策略（fallback 或正则化）

---

### B) 给每层增加“必须输出的最小诊断字段”（MUST/SHOULD）

你现在 Diagnostics 列表很全，但“字段可扩展”。 
建议改成 RFC 风格：

* MUST：`E_total`, `ΔE_layer`, `penetration_max`, `constraint_residual`, `failsafe.triggered`
* SHOULD：`λ_n, λ_t`, `complementarity_residual`, `α_blend`, `solver_iters`
  这样验收与论文画图会非常省力。

---

### C) 明确 EventLayer 的“接触模型族”与默认选择

你列了碰撞/堆叠/库仑摩擦，但没规定“默认实现是哪一类”：惩罚法？LCP？NCP？time-stepping？ 
规范里最好给一个**默认基线**（哪怕是最简版本），否则 M1 里“传统版本”会变成无穷选择题。 
例如：

* MVP：2D 点接触 + 恢复系数（解析） + 库仑摩擦（投影到摩擦圆）
* 扩展：多点堆叠 → LCP/NCP 或 projected Gauss-Seidel

---

### D) Fail-safe 触发条件建议区分“硬失败”和“软失败”

你现在把 NaN/Inf、穿透过大、互补残差不收敛、能量异常都列为触发。 
建议分级：

* Hard fail：NaN/Inf、求解器崩溃、穿透超硬阈值 → 必回退
* Soft fail：互补残差偏大、能量账本轻微违反 → 降级（限幅/混合），并继续迭代
  这样工程运行时不会“动不动全回退”。

---

### E) 评测协议里建议加入“模式一致性/事件准确率”

你有接触质量指标（最大穿透、互补残差、摩擦模式一致性）。 
如果你的论文叙事强调“事件层/突变过程”，建议加一个非常审稿友好的指标：

* 接触模式分类（分离/粘着/滑动/碰撞）的**混淆矩阵或 F1**（如果有标签或可从高精度仿真生成伪标签）
  它能把“看起来差不多”变成“模式学对没”。

---

### F) Roadmap 的“4周闭环”很棒，但建议把“产出物格式”写死

你在 M4 写了“统一脚本产出所有曲线/表格”。 
建议补一句：每个 milestone 必须产出：

* `configs/*.yaml`（固定种子、dt、场景参数）
* `logs/*.jsonl`（diagnostics 序列）
* `plots/*.png`（能量/穿透/约束/误差）
  这样复现性会更“论文级”。

---

## 最关键的三条改动建议（优先级最高）

1. **把约束从 ContactLayer 语义上拆出来**（至少在规范层面拆，避免账本语义混乱）。 
2. **把 C 层 ledger 从“功率”改成“离散功/能量跳变”并定义字段**。 
3. **指定 EventLayer 的 MVP 默认数值方案**（否则 M1 落地会分叉）。 

---

如果你愿意，我可以基于这份 spec 直接给你一个“v0.2 修订稿建议”（按你原有结构，逐段给替换文本），让你一贴就能升级文档。只要你告诉我：你更倾向把 EventLayer 的 MVP 选成 **解析冲量**（最简单）还是 **time-stepping + PGS**（更引擎味、更易扩展堆叠）。
